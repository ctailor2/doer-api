Auth flow

Authenticated request
1) API request
2) Server checks the request signature for a server issued secret referencing the authenticated user by some unique identifier
3) Unique identifier is used to find the acting user

Signup
1) Request to register a user includes:
	- unique identifier (email)
	- credentials (password)
2) Check repository to see if unique identifier is already used
3) Create user and add to repository
4) Add secured (hashed/salted) credentials to repository with a reference to the user via its unique identifier
5) Grant some form of unique identifier for the client making the request, referencing the authenticated user by some unique identifier:
	- unique identifier (token)
	- expiration date/time
6) Add identifier to repository

Login
1) Request to login a user includes:
	- unique identifier
	- credentials (password)
2) Find user from repository using the unique identifier
3) Check credentials
4) Grant some form of unique identifier for the client making the request, referencing the authenticated user by some unique identifier:
	- unique identifier
	- expiration date/time
5) Add identifier to repository

Domain relationships
--------------------

SessionToken --> User (reference should never go the other way around)

Actually, sessionToken shouldn't be a domain object at all.
Web layer exposes endpoints for clients to "authenticate" users - demonstrating that these users
are authentic (who they say they are) and can be linked to some user in the domain


domain __depends on__ application services
application services __depend on__ domain

application services __depend on__ application services


// Notes 12/28
- The api layer calls into the domain layer
- Certain domain services require a User (specified in an interface). For these, the api layer uses the authentication
service to obtain a User

api
- calls into the domain layer to create a user
- user passes into auth layer to register secret for the user
- auth layer can depend on storage layer, but should not depend on domain layer

// Notes 1/19
- I don't want the client to contain any business logic around when a task can
be scheduled for "now" versus "later", so maybe this can be managed with hateoas links
- Home resources will include a link to get todos
- The Get todos resources will include a link to create a task scheduled for "now" and
create a task scheduled for "later"
- If the number of "now" tasks is equal to the focus size (goal), then the get todos resources
will not include a link to create a task scheduled for "now" and the links for each active task will
include a link to displace it

// Notes 1/20
- The Web layer serves as a set of endpoints into the API layer
- The API layer serves as a set of entrypoints into the Domain
- The Domain layer exposes a set of actions that can be performed using its objects
- The Domain layer can also expose a workflow of some sort that indicates which actions can be performed
from any given point within the workflow. By including some introspective business logic, these workflows
weave the story in between the actions.
- These pieces are necessary to expose the business logic via a stateless protocol like HTTP

**Actually**

- Instead, the domain objects handled by the API layer should have business logic/rules baked into them
such that the web layer can inspect them and include/exclude links to other endpoints

// Notes 4/17
- Want to make it so later todos can only be requested once per day
- Also want to be able to request later todos multiple times within a short interval of time after requesting them for the first time that day