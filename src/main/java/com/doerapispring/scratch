Auth flow

Authenticated request
1) API request
2) Server checks the request signature for a server issued secret referencing the authenticated user by some unique identifier
3) Unique identifier is used to find the acting user

Signup
1) Request to register a user includes:
	- unique identifier (email)
	- credentials (password)
2) Check repository to see if unique identifier is already used
3) Create user and add to repository
4) Add secured (hashed/salted) credentials to repository with a reference to the user via its unique identifier
5) Grant some form of unique identifier for the client making the request, referencing the authenticated user by some unique identifier:
	- unique identifier (token)
	- expiration date/time
6) Add identifier to repository

Login
1) Request to login a user includes:
	- unique identifier
	- credentials (password)
2) Find user from repository using the unique identifier
3) Check credentials
4) Grant some form of unique identifier for the client making the request, referencing the authenticated user by some unique identifier:
	- unique identifier
	- expiration date/time
5) Add identifier to repository

Domain relationships
--------------------

SessionToken --> User (reference should never go the other way around)

Actually, sessionToken shouldn't be a domain object at all.
Web layer exposes endpoints for clients to "authenticate" users - demonstrating that these users
are authentic (who they say they are) and can be linked to some user in the domain


domain __depends on__ application services
application services __depend on__ domain

application services __depend on__ application services


// Notes 12/28
- The api layer calls into the domain layer
- Certain domain services require a User (specified in an interface). For these, the api layer uses the authentication
service to obtain a User

api
- calls into the domain layer to create a user
- user passes into auth layer to register secret for the user
- auth layer can depend on storage layer, but should not depend on domain layer

// Notes 1/19
- I don't want the client to contain any business logic around when a task can
be scheduled for "now" versus "later", so maybe this can be managed with hateoas links
- Home resources will include a link to get todos
- The Get todos resources will include a link to create a task scheduled for "now" and
create a task scheduled for "later"
- If the number of "now" tasks is equal to the focus size (goal), then the get todos resources
will not include a link to create a task scheduled for "now" and the links for each active task will
include a link to displace it

// Notes 1/20
- The Web layer serves as a set of endpoints into the API layer
- The API layer serves as a set of entrypoints into the Domain
- The Domain layer exposes a set of actions that can be performed using its objects
- The Domain layer can also expose a workflow of some sort that indicates which actions can be performed
from any given point within the workflow. By including some introspective business logic, these workflows
weave the story in between the actions.
- These pieces are necessary to expose the business logic via a stateless protocol like HTTP

**Actually**

- Instead, the domain objects handled by the API layer should have business logic/rules baked into them
such that the web layer can inspect them and include/exclude links to other endpoints

// Notes 1/22
- Need to change the home resources to include the create task links, since the home link is what gets stored
in the browser upon login and used as the starting point for everything
- But this gets weird if the idea is to have a dumb client for when it can/cannot add a task scheduled for "now".
For example, after posting a new task and retrieving the list of todos should the client get the home resources again?
- Or is it appropriate to have the home resources include a link for getting todos, and this endpoint returning
the links for creating todos?

// Notes 2/4
- Managing positions in the database is tricky

# left pipes represent the markers for the top of the now & later lists, respectively
# and their positions
# unpiped #s on the same line represent the positions stored in the database based on these markers
# 2nd line shows how the positions are resolved relative to the marker
# adding to the beginning of the now list moves the marker back one
# adding to the beginning of the later list moves the marker back one
# adding to the end of any list does not change any marker positions

|0|   |0|

|0| 1 |0| 1
	1     1

|-1|  0 1 |0| 1
	 -1 0     1

|-1|  0 1 2 |0| 1
	 -1 0 1     1

|-1|  0 1 2 |0| 1 2
	 -1 0 1     1 2


# when nothing on the side, don't change the marker
|0|

-1 |0|
-1

-1 |0| 1
-1     1

-1 |-1|  0 1
-2      -1 0

-1  0 |-1|  0 1
-2 -1      -1 0

# in general, the trouble with list positions comes from the push situation
# consider the following single list
# this is probably the best separation of concerns - bring back the 2 lists
|0| 1
	1

|-1|  0 1

|-1|  0 1 2

|-2| -1  0  1 2

|-1|  X  0  1 2       |-2| -1  X  1 2

|-1|  0  1 2          |-2| -1     1 2